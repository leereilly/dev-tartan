<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dev Tartan ‚Äî GitHub Username Tartan Generator</title>
  <meta name="description" content="Generate a unique tartan pattern from any GitHub username. Every developer deserves their own clan.">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Dev Tartan ‚Äî GitHub Username Tartan Generator">
  <meta property="og:description" content="Generate a unique tartan pattern from any GitHub username. Every developer deserves their own clan.">
  <meta property="og:url" content="https://leereilly.net/dev-tartan">
  <meta property="og:image" content="https://leereilly.net/dev-tartan/og-image.png">
  <meta property="og:site_name" content="Dev Tartan">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Dev Tartan ‚Äî GitHub Username Tartan Generator">
  <meta name="twitter:description" content="Generate a unique tartan pattern from any GitHub username. Every developer deserves their own clan.">
  <meta name="twitter:image" content="https://leereilly.net/dev-tartan/og-image.png">

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Crimson+Text:ital@0;1&display=swap');

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      min-height: 100vh;
      background: #f4edd3;
      background-image:
        repeating-linear-gradient(0deg, transparent, transparent 50px, rgba(139,119,75,0.03) 50px, rgba(139,119,75,0.03) 51px),
        repeating-linear-gradient(90deg, transparent, transparent 50px, rgba(139,119,75,0.03) 50px, rgba(139,119,75,0.03) 51px);
      font-family: 'Crimson Text', 'Georgia', serif;
      color: #2c1810;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem 1rem;
    }

    header {
      text-align: center;
      margin-bottom: 2rem;
    }

    header h1 {
      font-family: 'Playfair Display', 'Georgia', serif;
      font-size: 2.8rem;
      font-weight: 700;
      color: #1a0f08;
      letter-spacing: 0.04em;
      margin-bottom: 0.25rem;
    }

    header h1 .accent {
      color: #8b2500;
    }

    header p.subtitle {
      font-size: 1.15rem;
      font-style: italic;
      color: #6b5240;
      margin-top: 0.25rem;
    }

    .divider {
      width: 200px;
      height: 2px;
      background: linear-gradient(90deg, transparent, #8b774b, transparent);
      margin: 0.75rem auto;
    }

    .input-section {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      margin-bottom: 2rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .input-section label {
      font-family: 'Playfair Display', serif;
      font-size: 1.1rem;
      color: #3d2b1f;
    }

    .input-section input[type="text"] {
      font-family: 'Crimson Text', serif;
      font-size: 1.15rem;
      padding: 0.5rem 1rem;
      border: 2px solid #8b774b;
      border-radius: 4px;
      background: #faf6e9;
      color: #2c1810;
      width: 260px;
      outline: none;
      transition: border-color 0.2s;
    }

    .input-section input[type="text"]:focus {
      border-color: #8b2500;
    }

    .input-section input[type="text"]::placeholder {
      color: #b5a78a;
      font-style: italic;
    }

    button {
      font-family: 'Playfair Display', serif;
      font-size: 1rem;
      padding: 0.55rem 1.5rem;
      border: 2px solid #8b774b;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    button.generate-btn {
      background: #8b2500;
      color: #f4edd3;
      border-color: #6b1c00;
    }

    button.generate-btn:hover {
      background: #a52d00;
    }

    button.download-btn {
      background: #2c5234;
      color: #f4edd3;
      border-color: #1a3320;
      display: none;
    }

    button.download-btn:hover {
      background: #3a6b45;
    }

    button.bagpipe-btn {
      background: #5b2c6f;
      color: #f4edd3;
      border-color: #3d1a4a;
      display: none;
    }

    button.bagpipe-btn:hover {
      background: #7d3c98;
    }

    button.bagpipe-btn.playing {
      background: #8b1a1a;
      border-color: #6b1010;
      animation: pulse-glow 1s ease-in-out infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 4px rgba(139,26,26,0.3); }
      50% { box-shadow: 0 0 12px rgba(139,26,26,0.6); }
    }

    .share-links {
      display: none;
      gap: 0.6rem;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 1.5rem;
    }

    .share-links span {
      font-family: 'Playfair Display', serif;
      font-size: 0.95rem;
      color: #6b5240;
    }

    .share-links a {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      font-family: 'Crimson Text', serif;
      font-size: 0.9rem;
      color: #6b5240;
      text-decoration: none;
      padding: 0.3rem 0.6rem;
      border: 1px solid #c4b48a;
      border-radius: 3px;
      transition: all 0.2s;
    }

    .share-links a:hover {
      color: #8b2500;
      border-color: #8b2500;
      background: rgba(139,37,0,0.04);
    }

    .tartan-container {
      position: relative;
      margin-bottom: 1.5rem;
    }

    #tartan-display {
      border: 4px solid #8b774b;
      border-radius: 4px;
      box-shadow: 0 4px 20px rgba(44,24,16,0.15);
      background: #faf6e9;
      display: none;
    }

    .sett-display {
      display: none;
      margin-top: 1rem;
      text-align: center;
    }

    .sett-display h3 {
      font-family: 'Playfair Display', serif;
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      color: #3d2b1f;
    }

    .sett-colors {
      display: flex;
      gap: 4px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 0.5rem;
    }

    .sett-color {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .sett-swatch {
      width: 32px;
      height: 32px;
      border: 1px solid #8b774b;
      border-radius: 3px;
    }

    .sett-label {
      font-size: 0.7rem;
      color: #6b5240;
      font-family: monospace;
    }

    .sett-thread-count {
      font-size: 0.95rem;
      color: #6b5240;
      font-style: italic;
    }

    .palette-toggle {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(139,119,75,0.25);
    }

    .palette-toggle span {
      font-family: 'Playfair Display', serif;
      font-size: 0.95rem;
      color: #6b5240;
    }

    .palette-toggle label {
      font-family: 'Crimson Text', serif;
      font-size: 0.9rem;
      color: #6b5240;
      padding: 0.3rem 0.7rem;
      border: 1px solid #c4b48a;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .palette-toggle input[type="radio"] {
      display: none;
    }

    .palette-toggle input[type="radio"]:checked + label {
      color: #f4edd3;
      background: #8b2500;
      border-color: #6b1c00;
    }

    .palette-toggle label:hover {
      border-color: #8b2500;
      color: #8b2500;
    }

    .palette-toggle input[type="radio"]:checked + label:hover {
      color: #f4edd3;
    }

    .username-label {
      font-family: 'Playfair Display', serif;
      font-size: 1.25rem;
      color: #3d2b1f;
      margin-bottom: 0.5rem;
      display: none;
      text-align: center;
    }

    .username-label span {
      color: #8b2500;
      font-weight: 700;
    }

    .username-label .avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      vertical-align: middle;
      margin-left: 6px;
      border: 1.5px solid #8b774b;
    }

    footer {
      margin-top: auto;
      padding-top: 2rem;
      text-align: center;
      color: #8b774b;
      font-size: 0.9rem;
      font-style: italic;
    }

    @media (max-width: 600px) {
      header h1 { font-size: 2rem; }
      .input-section input[type="text"] { width: 200px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Dev <span class="accent">Tartan</span></h1>
    <div class="divider"></div>
    <p class="subtitle">Every developer deserves their own clan</p>
  </header>

  <form class="input-section" id="tartan-form">
    <label for="username">GitHub Username:</label>
    <input type="text" id="username" placeholder="e.g. octocat" autocomplete="off" required>
    <button type="submit" class="generate-btn">Weave Tartan</button>
    <button type="button" class="download-btn" id="download-btn">Download SVG</button>
    <button type="button" class="bagpipe-btn" id="bagpipe-btn">üéµ Play Bagpipes</button>
  </form>

  <div class="username-label" id="username-label">The tartan of <span id="display-name"></span><img class="avatar" id="user-avatar" src="" alt="" style="display:none;"></div>

  <div class="tartan-container">
    <svg id="tartan-display" width="500" height="500" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>

  <div class="sett-display" id="sett-display">
    <h3>Thread Count</h3>
    <div class="sett-colors" id="sett-colors"></div>
    <div class="sett-thread-count" id="sett-thread-count"></div>
  </div>

  <div class="share-links" id="share-links">
    <span>Share:</span>
    <a id="share-x" href="#" target="_blank" rel="noopener">ùïè</a>
    <a id="share-bluesky" href="#" target="_blank" rel="noopener">Bluesky</a>
    <a id="share-linkedin" href="#" target="_blank" rel="noopener">LinkedIn</a>
    <a id="share-threads" href="#" target="_blank" rel="noopener">Threads</a>
  </div>

  <div class="palette-toggle" id="palette-toggle">
    <span>Palette:</span>
    <input type="radio" name="palette" id="palette-traditional" value="traditional" checked>
    <label for="palette-traditional">Traditional</label>
    <input type="radio" name="palette" id="palette-github" value="github">
    <label for="palette-github">GitHub Green</label>
    <input type="radio" name="palette" id="palette-microsoft" value="microsoft">
    <label for="palette-microsoft">Microsoft</label>
  </div>

  <footer>
    <p>Woven with bits &amp; bytes &bull; SHA-256 &rarr; Sett</p>
    <p><a href="https://github.com/leereilly/dev-tartan" style="color: #8b774b;">Source on GitHub</a> &bull; Built with <a href="https://githubnext.com/projects/copilot-cli" style="color: #8b774b;">GitHub Copilot CLI</a> for the GitHub Copilot CLI Coding Challenge</p>
  </footer>

  <script>
    // Traditional tartan colour palette ‚Äî authentic Scottish dye colours
    const PALETTES = {
      traditional: [
        { name: 'Dark Navy',      hex: '#1c2541' },
        { name: 'Royal Blue',     hex: '#2b4c7e' },
        { name: 'Azure',          hex: '#3a7ca5' },
        { name: 'Sky Blue',       hex: '#6fb3d2' },
        { name: 'Hunter Green',   hex: '#1a472a' },
        { name: 'Forest Green',   hex: '#2d5a27' },
        { name: 'Moss Green',     hex: '#4a7c59' },
        { name: 'Sage',           hex: '#87a96b' },
        { name: 'Crimson',        hex: '#8b1a1a' },
        { name: 'Scarlet',        hex: '#c41e3a' },
        { name: 'Rust',           hex: '#a0522d' },
        { name: 'Burnt Orange',   hex: '#c76f30' },
        { name: 'Gold',           hex: '#c5a041' },
        { name: 'Straw',          hex: '#d4b94e' },
        { name: 'Purple',         hex: '#5b2c6f' },
        { name: 'Heather',        hex: '#7d5a9e' },
        { name: 'Black',          hex: '#1a1a1a' },
        { name: 'Charcoal',       hex: '#3d3d3d' },
        { name: 'Grey',           hex: '#7a7a7a' },
        { name: 'Ivory',          hex: '#f0e8d0' },
      ],
      github: [
        { name: 'Level 0',       hex: '#ebedf0' },
        { name: 'Level 1',       hex: '#9be9a8' },
        { name: 'Level 2',       hex: '#40c463' },
        { name: 'Level 3',       hex: '#30a14e' },
        { name: 'Level 4',       hex: '#216e39' },
        { name: 'Dark Green',    hex: '#0e4429' },
        { name: 'Light Green',   hex: '#b7e4c7' },
        { name: 'Mint',          hex: '#69d2a0' },
        { name: 'Emerald',       hex: '#28a745' },
        { name: 'Pine',          hex: '#176f2c' },
        { name: 'Deep Forest',   hex: '#0d5524' },
        { name: 'Mist',          hex: '#d1f0dc' },
        { name: 'Seafoam',       hex: '#85e0a3' },
        { name: 'Clover',        hex: '#34d058' },
        { name: 'Fern',          hex: '#22863a' },
        { name: 'Ivy',           hex: '#144620' },
        { name: 'Ash',           hex: '#c6ced3' },
        { name: 'Slate',         hex: '#586069' },
        { name: 'Charcoal',      hex: '#24292e' },
        { name: 'Snow',          hex: '#f6f8fa' },
      ],
      microsoft: [
        { name: 'MS Red',        hex: '#f25022' },
        { name: 'MS Green',      hex: '#7fba00' },
        { name: 'MS Blue',       hex: '#00a4ef' },
        { name: 'MS Yellow',     hex: '#ffb900' },
        { name: 'Dark Red',      hex: '#a33b1f' },
        { name: 'Dark Green',    hex: '#4e7a00' },
        { name: 'Dark Blue',     hex: '#0078d4' },
        { name: 'Dark Yellow',   hex: '#d48c00' },
        { name: 'Light Red',     hex: '#f7816b' },
        { name: 'Light Green',   hex: '#b4e44b' },
        { name: 'Light Blue',    hex: '#50c8ff' },
        { name: 'Light Yellow',  hex: '#ffd54f' },
        { name: 'Coral',         hex: '#e8503a' },
        { name: 'Lime',          hex: '#6ba300' },
        { name: 'Azure',         hex: '#0063b1' },
        { name: 'Amber',         hex: '#e69500' },
        { name: 'Black',         hex: '#1a1a1a' },
        { name: 'Charcoal',      hex: '#3d3d3d' },
        { name: 'Grey',          hex: '#737373' },
        { name: 'White',         hex: '#f2f2f2' },
      ],
    };

    let currentPalette = 'traditional';
    let TARTAN_PALETTE = PALETTES.traditional;

    // Hash a string to SHA-256 and return byte array
    async function sha256(str) {
      const data = new TextEncoder().encode(str);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      return new Uint8Array(hashBuffer);
    }

    // Derive a tartan sett (colour+width sequence) from hash bytes
    function deriveSett(hashBytes) {
      // Determine number of colours: 4-6, from first byte
      const numColors = 4 + (hashBytes[0] % 3); // 4, 5, or 6

      // Pick colours from palette using hash bytes
      const colors = [];
      for (let i = 0; i < numColors; i++) {
        const idx = hashBytes[1 + i] % TARTAN_PALETTE.length;
        const color = TARTAN_PALETTE[idx];
        // Avoid duplicate colours
        if (!colors.find(c => c.hex === color.hex)) {
          colors.push(color);
        } else {
          // Pick next available
          const altIdx = (idx + 7) % TARTAN_PALETTE.length;
          colors.push(TARTAN_PALETTE[altIdx]);
        }
      }

      // Derive thread counts (widths) from subsequent hash bytes
      // Traditional tartans have varying stripe widths: thin (2-6), medium (8-16), wide (18-36)
      const threadCounts = [];
      for (let i = 0; i < colors.length; i++) {
        const byte = hashBytes[8 + i];
        // Map byte to a thread count: bias toward variety
        let count;
        if (byte < 64) {
          count = 2 + (byte % 5);       // thin: 2-6
        } else if (byte < 180) {
          count = 8 + (byte % 9);        // medium: 8-16
        } else {
          count = 18 + (byte % 19);      // wide: 18-36
        }
        threadCounts.push(count);
      }

      // Build the sett: sequence of { color, width }
      const sett = colors.map((c, i) => ({
        color: c,
        width: threadCounts[i]
      }));

      return sett;
    }

    // Create the full symmetric stripe sequence from a sett
    // Traditional tartans reflect: A B C D C B A B C D C B A ...
    function expandSett(sett) {
      if (sett.length <= 1) return sett;
      // pivot: full sett forward, then reverse without first and last (mirror)
      const forward = [...sett];
      const reverse = [...sett].slice(1, -1).reverse();
      return [...forward, ...reverse];
    }

    // Render the tartan SVG with weaving animation
    function renderTartan(svg, sett, size = 500, animate = true) {
      svg.innerHTML = '';
      svg.setAttribute('width', size);
      svg.setAttribute('height', size);
      svg.setAttribute('viewBox', `0 0 ${size} ${size}`);

      const symmetricSett = expandSett(sett);

      // Calculate total width of one repeat
      const repeatWidth = symmetricSett.reduce((sum, s) => sum + s.width, 0);
      if (repeatWidth === 0) return;

      // Scale factor to fill the SVG nicely (aim for ~3-4 repeats)
      const targetRepeats = 3;
      const scale = size / (repeatWidth * targetRepeats);

      // Create defs for the pattern and clip path
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

      // Clip path to keep everything inside the canvas
      const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
      clipPath.setAttribute('id', 'tartan-clip');
      const clipRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      clipRect.setAttribute('width', size);
      clipRect.setAttribute('height', size);
      clipPath.appendChild(clipRect);
      defs.appendChild(clipPath);

      // Background
      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bg.setAttribute('width', size);
      bg.setAttribute('height', size);
      bg.setAttribute('fill', sett[0].color.hex);
      if (animate) bg.setAttribute('opacity', '0');
      svg.appendChild(bg);

      // Draw warp (vertical stripes) with reduced opacity
      const warpGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      warpGroup.setAttribute('opacity', '0.9');
      warpGroup.setAttribute('clip-path', 'url(#tartan-clip)');
      const warpRects = [];
      let x = 0;
      while (x < size) {
        for (const stripe of symmetricSett) {
          const w = stripe.width * scale;
          if (x + w > size + w) break;
          const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rect.setAttribute('x', x);
          rect.setAttribute('width', Math.ceil(w));
          rect.setAttribute('height', size);
          rect.setAttribute('fill', stripe.color.hex);
          if (animate) {
            rect.setAttribute('y', -size);
          } else {
            rect.setAttribute('y', 0);
          }
          warpGroup.appendChild(rect);
          warpRects.push(rect);
          x += w;
        }
      }
      svg.appendChild(warpGroup);

      // Draw weft (horizontal stripes) with transparency for woven effect
      const weftGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      weftGroup.setAttribute('opacity', '0.55');
      weftGroup.setAttribute('style', 'mix-blend-mode: multiply;');
      weftGroup.setAttribute('clip-path', 'url(#tartan-clip)');
      const weftRects = [];
      let y = 0;
      while (y < size) {
        for (const stripe of symmetricSett) {
          const h = stripe.width * scale;
          if (y + h > size + h) break;
          const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rect.setAttribute('y', y);
          rect.setAttribute('height', Math.ceil(h));
          rect.setAttribute('width', size);
          rect.setAttribute('fill', stripe.color.hex);
          if (animate) {
            rect.setAttribute('x', -size);
          } else {
            rect.setAttribute('x', 0);
          }
          weftGroup.appendChild(rect);
          weftRects.push(rect);
          y += h;
        }
      }
      svg.appendChild(weftGroup);

      // Add subtle twill texture overlay for authenticity
      const twillPattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
      twillPattern.setAttribute('id', 'twill');
      twillPattern.setAttribute('width', '4');
      twillPattern.setAttribute('height', '4');
      twillPattern.setAttribute('patternUnits', 'userSpaceOnUse');

      const twillLine1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      twillLine1.setAttribute('x', '0'); twillLine1.setAttribute('y', '0');
      twillLine1.setAttribute('width', '2'); twillLine1.setAttribute('height', '2');
      twillLine1.setAttribute('fill', 'rgba(255,255,255,0.04)');
      twillPattern.appendChild(twillLine1);

      const twillLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      twillLine2.setAttribute('x', '2'); twillLine2.setAttribute('y', '2');
      twillLine2.setAttribute('width', '2'); twillLine2.setAttribute('height', '2');
      twillLine2.setAttribute('fill', 'rgba(0,0,0,0.04)');
      twillPattern.appendChild(twillLine2);

      defs.appendChild(twillPattern);
      svg.insertBefore(defs, svg.firstChild);

      const twillOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      twillOverlay.setAttribute('width', size);
      twillOverlay.setAttribute('height', size);
      twillOverlay.setAttribute('fill', 'url(#twill)');
      if (animate) twillOverlay.setAttribute('opacity', '0');
      svg.appendChild(twillOverlay);

      // Animate the weaving
      if (animate) {
        animateWeaving(bg, warpRects, weftRects, twillOverlay, size);
      }
    }

    // Animate warp threads dropping in, then weft threads sliding in
    function animateWeaving(bg, warpRects, weftRects, twillOverlay, size) {
      const warpDuration = 600;   // ms for all warp threads
      const weftDuration = 600;   // ms for all weft threads
      const staggerMax = 80;      // max stagger offset between first and last thread
      const easeOut = t => 1 - Math.pow(1 - t, 3); // cubic ease-out

      // Fade in background
      bg.setAttribute('opacity', '1');
      bg.style.transition = 'opacity 0.3s ease';

      const startTime = performance.now();

      function tick(now) {
        const elapsed = now - startTime;

        // Phase 1: Warp threads drop in (0 ‚Üí warpDuration)
        if (elapsed < warpDuration + staggerMax) {
          for (let i = 0; i < warpRects.length; i++) {
            const stagger = (i / Math.max(warpRects.length - 1, 1)) * staggerMax;
            const t = Math.max(0, Math.min(1, (elapsed - stagger) / warpDuration));
            const easedT = easeOut(t);
            const yPos = -size + easedT * size;
            warpRects[i].setAttribute('y', yPos);
          }
        } else {
          // Snap warp to final position
          for (const r of warpRects) r.setAttribute('y', 0);
        }

        // Phase 2: Weft threads slide in (after warp finishes, with slight overlap)
        const weftStart = warpDuration * 0.6;
        if (elapsed > weftStart) {
          const weftElapsed = elapsed - weftStart;
          for (let i = 0; i < weftRects.length; i++) {
            const stagger = (i / Math.max(weftRects.length - 1, 1)) * staggerMax;
            const t = Math.max(0, Math.min(1, (weftElapsed - stagger) / weftDuration));
            const easedT = easeOut(t);
            const xPos = -size + easedT * size;
            weftRects[i].setAttribute('x', xPos);
          }
        }

        // Phase 3: Fade in twill overlay
        const twillStart = weftStart + weftDuration * 0.5;
        if (elapsed > twillStart) {
          const twillT = Math.min(1, (elapsed - twillStart) / 400);
          twillOverlay.setAttribute('opacity', twillT);
        }

        // Keep animating until everything is done
        const totalDuration = weftStart + weftDuration + staggerMax + 400;
        if (elapsed < totalDuration) {
          requestAnimationFrame(tick);
        } else {
          // Snap everything to final state
          for (const r of warpRects) r.setAttribute('y', 0);
          for (const r of weftRects) r.setAttribute('x', 0);
          twillOverlay.setAttribute('opacity', '1');
        }
      }

      requestAnimationFrame(tick);
    }

    // Display the sett information
    function displaySett(sett) {
      const colorsDiv = document.getElementById('sett-colors');
      const threadCountDiv = document.getElementById('sett-thread-count');
      colorsDiv.innerHTML = '';

      const threadParts = [];
      sett.forEach(s => {
        const swatch = document.createElement('div');
        swatch.className = 'sett-color';
        swatch.innerHTML = `
          <div class="sett-swatch" style="background:${s.color.hex}"></div>
          <span class="sett-label">${s.color.name}</span>
        `;
        colorsDiv.appendChild(swatch);

        // Thread count abbreviation: first letter of colour name + count
        const abbr = s.color.name.split(' ').map(w => w[0]).join('');
        threadParts.push(`${abbr}/${s.width}`);
      });

      threadCountDiv.textContent = threadParts.join('  ');
      document.getElementById('sett-display').style.display = 'block';
    }

    // Download SVG
    function downloadSVG() {
      const svg = document.getElementById('tartan-display');
      const serializer = new XMLSerializer();
      let source = serializer.serializeToString(svg);

      // Add XML declaration and namespace
      if (!source.includes('xmlns=')) {
        source = source.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
      }
      source = '<?xml version="1.0" encoding="UTF-8"?>\n' + source;

      const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const username = document.getElementById('username').value.trim();
      a.href = url;
      a.download = `${username}-tartan.svg`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Main generate handler
    async function generateTartan(username) {
      if (bagpipePlaying) stopBagpipes();
      const hashBytes = await sha256(username.toLowerCase());
      const sett = deriveSett(hashBytes);

      const svg = document.getElementById('tartan-display');
      renderTartan(svg, sett);

      svg.style.display = 'block';
      document.getElementById('download-btn').style.display = 'inline-block';
      document.getElementById('bagpipe-btn').style.display = 'inline-block';
      document.getElementById('username-label').style.display = 'block';
      document.getElementById('display-name').textContent = username;

      // Show user avatar
      const avatar = document.getElementById('user-avatar');
      avatar.src = `https://github.com/${encodeURIComponent(username)}.png?size=56`;
      avatar.alt = username;
      avatar.style.display = 'inline';
      avatar.onerror = function() { this.style.display = 'none'; };

      displaySett(sett);

      // Use the tartan as a repeating background with high contrast (near-white)
      setTartanBackground(sett);

      // Update share links
      updateShareLinks(username);
    }

    // Update social share links
    function updateShareLinks(username) {
      const paletteSuffix = currentPalette !== 'traditional' ? `&palette=${encodeURIComponent(currentPalette)}` : '';
      const url = `https://leereilly.net/dev-tartan?username=${encodeURIComponent(username)}${paletteSuffix}`;
      const text = `I generated my developer tartan: ${url}`;
      const encodedText = encodeURIComponent(text);
      const encodedUrl = encodeURIComponent(url);

      document.getElementById('share-x').href =
        `https://x.com/intent/tweet?text=${encodedText}`;
      document.getElementById('share-bluesky').href =
        `https://bsky.app/intent/compose?text=${encodedText}`;
      document.getElementById('share-linkedin').href =
        `https://www.linkedin.com/sharing/share-offsite/?url=${encodedUrl}`;
      document.getElementById('share-threads').href =
        `https://threads.net/intent/post?text=${encodedText}`;

      document.getElementById('share-links').style.display = 'flex';
    }

    // Set the page background to a faded repeating tartan tile
    function setTartanBackground(sett) {
      const tileSize = 160;
      const symmetricSett = expandSett(sett);
      const repeatWidth = symmetricSett.reduce((sum, s) => sum + s.width, 0);
      if (repeatWidth === 0) return;
      const scale = tileSize / repeatWidth;

      let svgParts = [];
      svgParts.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${tileSize}" height="${tileSize}">`);
      // White base so the washed-out pattern stays near-white
      svgParts.push(`<rect width="${tileSize}" height="${tileSize}" fill="#f4edd3"/>`);

      // Warp (vertical stripes) at very low opacity
      svgParts.push(`<g opacity="0.08">`);
      let x = 0;
      for (const stripe of symmetricSett) {
        const w = stripe.width * scale;
        svgParts.push(`<rect x="${x}" y="0" width="${Math.ceil(w)}" height="${tileSize}" fill="${stripe.color.hex}"/>`);
        x += w;
      }
      svgParts.push(`</g>`);

      // Weft (horizontal stripes) at very low opacity
      svgParts.push(`<g opacity="0.06">`);
      let y = 0;
      for (const stripe of symmetricSett) {
        const h = stripe.width * scale;
        svgParts.push(`<rect x="0" y="${y}" width="${tileSize}" height="${Math.ceil(h)}" fill="${stripe.color.hex}"/>`);
        y += h;
      }
      svgParts.push(`</g>`);

      svgParts.push(`</svg>`);

      const svgDataUri = 'data:image/svg+xml,' + encodeURIComponent(svgParts.join(''));
      document.body.style.backgroundImage = `url("${svgDataUri}")`;
      document.body.style.backgroundRepeat = 'repeat';
      document.body.style.backgroundSize = `${tileSize}px ${tileSize}px`;
    }

    // ‚îÄ‚îÄ Bagpipe Audio Engine (Web Audio API) ‚îÄ‚îÄ
    // Realistic Great Highland Bagpipe synthesis using additive harmonics,
    // breath noise, legato chanter, grace notes, and rich multi-harmonic drones.

    let bagpipeCtx = null;
    let bagpipePlaying = false;
    let bagpipeStopTimer = null;

    // GHB chanter scale (A=480Hz concert pitch, bagpipe tuning ~475-480Hz)
    // Low A to High A with sharped 7th (characteristic mixolydian)
    const BAGPIPE_SCALE = [
      480.00 * 0.5,    // Low G
      480.00 * 9/16,   // Low A
      480.00 * 5/8,    // B
      480.00 * 3/4,    // C (actually C#-ish in bagpipe temperament)
      480.00 * 3/4 * 1.04, // D
      480.00 * 7/8,    // E
      480.00 * 15/16,  // F (actually F#-ish)
      480.00,          // High G
      480.00 * 9/8,    // High A
    ];

    // Drone frequencies ‚Äî Bb-based, with authentic bagpipe tuning
    const BASS_DRONE_FREQ = 120.0;    // Bass drone ~Bb2
    const TENOR_DRONE_FREQ = 240.0;   // Tenor drones ~Bb3

    // Build a PeriodicWave for reed-like timbre (chanter)
    // Strong odd harmonics + weaker even harmonics = nasal/reedy
    function chanterWave(ctx) {
      const n = 24;
      const real = new Float32Array(n);
      const imag = new Float32Array(n);
      real[0] = 0;
      imag[0] = 0;
      for (let h = 1; h < n; h++) {
        // Strong fundamental + odd harmonics, rolled-off even harmonics
        const isOdd = h % 2 === 1;
        const amp = (isOdd ? 1.0 : 0.3) / Math.pow(h, 0.75);
        // Slight formant bump around 3rd-5th harmonic for nasal quality
        const formant = (h >= 3 && h <= 6) ? 1.6 : 1.0;
        imag[h] = amp * formant;
      }
      return ctx.createPeriodicWave(real, imag, { disableNormalization: false });
    }

    // Build a PeriodicWave for drone ‚Äî rich, buzzy, warm
    function droneWave(ctx) {
      const n = 32;
      const real = new Float32Array(n);
      const imag = new Float32Array(n);
      real[0] = 0;
      imag[0] = 0;
      for (let h = 1; h < n; h++) {
        // All harmonics present, rolling off like a sawtooth but warmer
        imag[h] = 1.0 / Math.pow(h, 0.9);
      }
      return ctx.createPeriodicWave(real, imag, { disableNormalization: false });
    }

    // Create filtered breath noise (constant, air-through-bag character)
    function createBreathNoise(ctx, destination, gain) {
      const bufferSize = ctx.sampleRate * 2;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1);
      }
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      noise.loop = true;

      // Shape noise: bandpass to sound like air through a reed
      const bp = ctx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 1200;
      bp.Q.value = 0.8;

      // Second filter for high-frequency hiss
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 2500;

      const noiseGain = ctx.createGain();
      noiseGain.gain.value = gain;

      noise.connect(bp);
      bp.connect(noiseGain);

      // Also route a quieter high hiss
      const hissGain = ctx.createGain();
      hissGain.gain.value = gain * 0.3;
      noise.connect(hp);
      hp.connect(hissGain);
      hissGain.connect(destination);

      noiseGain.connect(destination);
      noise.start();
      return { source: noise, gain: noiseGain, hissGain };
    }

    // Create a single drone pipe with multiple detuned oscillators
    function createDronePipe(ctx, freq, destination, gain, wave) {
      const oscs = [];
      // Three slightly detuned oscillators for chorus/beating
      const detunes = [0, -4, +5]; // cents
      const subGain = ctx.createGain();
      subGain.gain.value = gain;

      for (const det of detunes) {
        const osc = ctx.createOscillator();
        osc.setPeriodicWave(wave);
        osc.frequency.value = freq;
        osc.detune.value = det;
        osc.connect(subGain);
        osc.start();
        oscs.push(osc);
      }

      // Resonant low-pass to warm the drone
      const lp = ctx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = freq * 6;
      lp.Q.value = 0.7;

      subGain.connect(lp);
      lp.connect(destination);

      return { oscillators: oscs, gain: subGain, filter: lp };
    }

    // Schedule a single chanter note (additive synthesis with the reed wave)
    function scheduleNote(ctx, freq, startTime, duration, destination, wave, vol) {
      // Main chanter oscillator
      const osc1 = ctx.createOscillator();
      osc1.setPeriodicWave(wave);
      osc1.frequency.value = freq;

      // Second oscillator slightly detuned for thickness
      const osc2 = ctx.createOscillator();
      osc2.setPeriodicWave(wave);
      osc2.frequency.value = freq;
      osc2.detune.value = 3; // 3 cents sharp

      // Slow vibrato via LFO (bagpipes have subtle pitch waver from bag pressure)
      const vibrato = ctx.createOscillator();
      vibrato.frequency.value = 4.5; // ~4-5 Hz
      const vibratoGain = ctx.createGain();
      vibratoGain.gain.value = 2.5; // subtle pitch bend in cents
      vibrato.connect(vibratoGain);
      vibratoGain.connect(osc1.detune);
      vibratoGain.connect(osc2.detune);
      vibrato.start(startTime);
      vibrato.stop(startTime + duration + 0.05);

      // Formant filter chain ‚Äî nasal resonance
      const formant1 = ctx.createBiquadFilter();
      formant1.type = 'peaking';
      formant1.frequency.value = freq * 3;
      formant1.gain.value = 6;
      formant1.Q.value = 2;

      const formant2 = ctx.createBiquadFilter();
      formant2.type = 'peaking';
      formant2.frequency.value = freq * 5;
      formant2.gain.value = 3;
      formant2.Q.value = 3;

      // Roll off very high frequencies
      const lp = ctx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 4500;
      lp.Q.value = 0.5;

      const noteGain = ctx.createGain();
      // Legato ‚Äî no silence between notes, just quick transitions
      noteGain.gain.setValueAtTime(0.001, startTime);
      noteGain.gain.exponentialRampToValueAtTime(vol, startTime + 0.008);
      noteGain.gain.setValueAtTime(vol, startTime + duration - 0.008);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

      osc1.connect(formant1);
      osc2.connect(formant1);
      formant1.connect(formant2);
      formant2.connect(lp);
      lp.connect(noteGain);
      noteGain.connect(destination);

      osc1.start(startTime);
      osc1.stop(startTime + duration + 0.01);
      osc2.start(startTime);
      osc2.stop(startTime + duration + 0.01);
    }

    // Schedule a very short grace note (embellishment) ‚Äî characteristic of piping
    function scheduleGraceNote(ctx, freq, startTime, destination, wave) {
      const dur = 0.035;
      const osc = ctx.createOscillator();
      osc.setPeriodicWave(wave);
      osc.frequency.value = freq;

      const gn = ctx.createGain();
      gn.gain.setValueAtTime(0.001, startTime);
      gn.gain.exponentialRampToValueAtTime(0.10, startTime + 0.005);
      gn.gain.exponentialRampToValueAtTime(0.001, startTime + dur);

      const lp = ctx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 4000;

      osc.connect(lp);
      lp.connect(gn);
      gn.connect(destination);

      osc.start(startTime);
      osc.stop(startTime + dur + 0.01);
      return dur;
    }

    // Derive a melody from hash bytes
    function deriveMelody(hashBytes) {
      const notes = [];
      const numNotes = 20 + (hashBytes[20] % 12); // 20-31 notes

      for (let i = 0; i < numNotes; i++) {
        const byte = hashBytes[(i + 16) % 32];
        const noteIndex = byte % BAGPIPE_SCALE.length;

        const durByte = hashBytes[(i + 17) % 32];
        let duration;
        if (durByte < 60) duration = 0.18;        // short
        else if (durByte < 140) duration = 0.32;   // quaver
        else if (durByte < 210) duration = 0.48;   // crotchet
        else duration = 0.7;                        // minim

        // Determine if a grace note precedes this note (very common in piping)
        const graceFlag = hashBytes[(i + 3) % 32];
        const hasGrace = graceFlag > 80; // ~70% of notes get grace notes
        // Grace note pitch: high A or high G (common embellishments)
        const graceNoteIndex = (graceFlag % 2 === 0) ? 8 : 7; // High A or High G

        notes.push({ noteIndex, duration, hasGrace, graceNoteIndex });
      }
      return notes;
    }

    // Simple delay-based reverb for room ambience
    function createReverb(ctx, destination) {
      const delays = [0.03, 0.07, 0.11, 0.17];
      const gains = [0.15, 0.10, 0.07, 0.04];
      const input = ctx.createGain();
      input.gain.value = 1.0;

      // Dry path
      input.connect(destination);

      // Wet paths (multiple delays)
      for (let i = 0; i < delays.length; i++) {
        const delay = ctx.createDelay(0.3);
        delay.delayTime.value = delays[i];
        const g = ctx.createGain();
        g.gain.value = gains[i];
        const lp = ctx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.value = 2000 - i * 300;
        input.connect(delay);
        delay.connect(lp);
        lp.connect(g);
        g.connect(destination);
      }
      return input;
    }

    async function playBagpipes(username) {
      if (bagpipePlaying) {
        stopBagpipes();
        return;
      }

      const hashBytes = await sha256(username.toLowerCase());
      const melody = deriveMelody(hashBytes);

      bagpipeCtx = new (window.AudioContext || window.webkitAudioContext)();
      bagpipePlaying = true;

      const btn = document.getElementById('bagpipe-btn');
      btn.textContent = '‚èπ Stop Bagpipes';
      btn.classList.add('playing');

      const ctx = bagpipeCtx;

      // Master chain: reverb ‚Üí compressor ‚Üí destination
      const compressor = ctx.createDynamicsCompressor();
      compressor.threshold.value = -18;
      compressor.knee.value = 6;
      compressor.ratio.value = 6;
      compressor.attack.value = 0.003;
      compressor.release.value = 0.15;
      compressor.connect(ctx.destination);

      const reverb = createReverb(ctx, compressor);

      const master = ctx.createGain();
      master.gain.value = 0.55;
      master.connect(reverb);

      // Build waveforms
      const cWave = chanterWave(ctx);
      const dWave = droneWave(ctx);

      // ‚îÄ‚îÄ Drones ‚îÄ‚îÄ
      const bassDrone = createDronePipe(ctx, BASS_DRONE_FREQ, master, 0.07, dWave);
      const tenorDrone1 = createDronePipe(ctx, TENOR_DRONE_FREQ, master, 0.055, dWave);
      const tenorDrone2 = createDronePipe(ctx, TENOR_DRONE_FREQ * 1.001, master, 0.055, dWave);

      // ‚îÄ‚îÄ Breath noise ‚îÄ‚îÄ
      const breathNoise = createBreathNoise(ctx, master, 0.012);

      // Fade everything in over 1.5s (bag filling up, drones starting)
      const allDrones = [bassDrone, tenorDrone1, tenorDrone2];
      allDrones.forEach(d => {
        const target = d.gain.gain.value;
        d.gain.gain.setValueAtTime(0, ctx.currentTime);
        d.gain.gain.linearRampToValueAtTime(target * 0.3, ctx.currentTime + 0.4);
        d.gain.gain.linearRampToValueAtTime(target, ctx.currentTime + 1.5);
      });
      breathNoise.gain.gain.setValueAtTime(0, ctx.currentTime);
      breathNoise.gain.gain.linearRampToValueAtTime(0.012, ctx.currentTime + 1.0);

      // ‚îÄ‚îÄ Schedule chanter melody ‚îÄ‚îÄ
      let time = ctx.currentTime + 1.8; // drones settle first

      for (let i = 0; i < melody.length; i++) {
        const note = melody[i];
        const freq = BAGPIPE_SCALE[note.noteIndex];

        // Grace note embellishment
        if (note.hasGrace && i > 0) {
          const graceFreq = BAGPIPE_SCALE[note.graceNoteIndex];
          const graceDur = scheduleGraceNote(ctx, graceFreq, time, master, cWave);
          time += graceDur;
        }

        // Main note ‚Äî legato, no gap
        scheduleNote(ctx, freq, time, note.duration, master, cWave, 0.14);
        time += note.duration;
      }

      // Fade drones out after melody
      const fadeStart = time + 0.3;
      const endTime = fadeStart + 1.5;
      allDrones.forEach(d => {
        d.gain.gain.setValueAtTime(d.gain.gain.value, fadeStart);
        d.gain.gain.linearRampToValueAtTime(0, endTime);
        d.oscillators.forEach(o => o.stop(endTime + 0.1));
      });
      breathNoise.gain.gain.setValueAtTime(0.012, fadeStart);
      breathNoise.gain.gain.linearRampToValueAtTime(0, endTime);
      breathNoise.source.stop(endTime + 0.1);

      // Auto-stop
      const totalMs = (endTime - ctx.currentTime + 0.3) * 1000;
      bagpipeStopTimer = setTimeout(() => {
        if (bagpipePlaying) stopBagpipes();
      }, totalMs);
    }

    function stopBagpipes() {
      bagpipePlaying = false;
      if (bagpipeStopTimer) { clearTimeout(bagpipeStopTimer); bagpipeStopTimer = null; }
      const btn = document.getElementById('bagpipe-btn');
      btn.textContent = 'üéµ Play Bagpipes';
      btn.classList.remove('playing');

      if (bagpipeCtx) {
        bagpipeCtx.close().catch(() => {});
        bagpipeCtx = null;
      }
    }

    // Event listeners
    document.getElementById('tartan-form').addEventListener('submit', (e) => {
      e.preventDefault();
      const username = document.getElementById('username').value.trim().replace(/^@/, '');
      if (username) {
        // Update URL with query parameter (no page reload)
        const url = new URL(window.location);
        url.searchParams.set('username', username);
        if (currentPalette !== 'traditional') {
          url.searchParams.set('palette', currentPalette);
        } else {
          url.searchParams.delete('palette');
        }
        url.hash = '';
        window.history.replaceState({}, '', url);
        generateTartan(username);
      }
    });

    document.getElementById('download-btn').addEventListener('click', downloadSVG);

    document.getElementById('bagpipe-btn').addEventListener('click', () => {
      const username = document.getElementById('username').value.trim().replace(/^@/, '');
      if (username) playBagpipes(username);
    });

    // Palette toggle
    document.querySelectorAll('input[name="palette"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        currentPalette = e.target.value;
        TARTAN_PALETTE = PALETTES[currentPalette];
        const url = new URL(window.location);
        if (currentPalette !== 'traditional') {
          url.searchParams.set('palette', currentPalette);
        } else {
          url.searchParams.delete('palette');
        }
        window.history.replaceState({}, '', url);
        const username = document.getElementById('username').value.trim().replace(/^@/, '');
        if (username) generateTartan(username);
      });
    });

    // Generate from ?username= and ?palette= query parameters or #hash on page load
    (function autoGenerate() {
      const params = new URLSearchParams(window.location.search);
      const paletteParam = (params.get('palette') || '').trim().toLowerCase();
      if (paletteParam && PALETTES[paletteParam]) {
        currentPalette = paletteParam;
        TARTAN_PALETTE = PALETTES[currentPalette];
        document.getElementById('palette-' + currentPalette).checked = true;
      }
      const fromQuery = (params.get('username') || '').trim().replace(/^@/, '');
      const fromHash = window.location.hash
        ? decodeURIComponent(window.location.hash.slice(1)).replace(/^@/, '')
        : '';
      const username = fromQuery || fromHash;
      if (username) {
        document.getElementById('username').value = username;
        generateTartan(username);
      }
    })();
  </script>
</body>
</html>
